#!/bin/sh

# OPNsense Tunnel Agent v2.0.9
# This script establishes a reverse tunnel connection to the management server
# The management server can then proxy connections through this tunnel

AGENT_VERSION="2.0.9"
MANAGEMENT_SERVER="opn.agit8or.net"
FIREWALL_ID="21"
AUTH_TOKEN="tunnel_auth_$(date +%s)"
LOCAL_WEB_PORT="80"
CHECKIN_INTERVAL="120"  # 2 minutes

echo "OPNsense Tunnel Agent starting..."
echo "Management Server: $MANAGEMENT_SERVER"
echo "Firewall ID: $FIREWALL_ID"

# Self-cleanup on startup - remove old artifacts
echo "Performing startup cleanup..."
ps aux | grep -E "(tunnel_agent|opnsense_agent)" | grep -v $$ | grep -v grep | awk '{print $2}' | xargs kill -9 2>/dev/null
rm -f /tmp/tunnel_agent* /tmp/opnsense_agent* 2>/dev/null
rm -f /usr/local/bin/opnsense_agent* 2>/dev/null

# Function to establish tunnel connection
establish_tunnel() {
    echo "Establishing tunnel connection..."
    
    # Notify management server of tunnel
    RESPONSE=$(curl -s -k -X POST "https://$MANAGEMENT_SERVER/api/tunnel_connect.php" \
        -H "Content-Type: application/json" \
        -d "{
            \"firewall_id\": $FIREWALL_ID,
            \"auth_token\": \"$AUTH_TOKEN\",
            \"tunnel_port\": $LOCAL_WEB_PORT
        }")
    
    echo "Server response: $RESPONSE"
    
    if echo "$RESPONSE" | grep -q '"success":true'; then
        echo "✓ Tunnel connection established successfully"
        return 0
    else
        echo "✗ Failed to establish tunnel connection"
        return 1
    fi
}

# Function to poll for requests and handle them
handle_requests() {
    while true; do
        # Poll for pending requests
        REQUESTS=$(curl -s -k "https://$MANAGEMENT_SERVER/api/request_queue.php?action=poll_requests&firewall_id=$FIREWALL_ID")
        
        if echo "$REQUESTS" | grep -q '"success":true'; then
            # Process each request
            echo "$REQUESTS" | python3 -c "
import json, sys, subprocess, urllib.parse, base64
try:
    data = json.load(sys.stdin)
    if data.get('success') and data.get('requests'):
        for req in data['requests']:
            req_id = req['id']
            method = req['method']
            path = req['path']
            headers = json.loads(req['headers'])
            body = req['body']
            
            # Make request to local OPNsense
            curl_cmd = ['curl', '-s', '-k', '-X', method]
            
            # Add headers
            for name, value in headers.items():
                if name.lower() not in ['host', 'connection']:
                    curl_cmd.extend(['-H', f'{name}: {value}'])
            
            # Add body if present
            if body:
                curl_cmd.extend(['-d', body])
            
            # Debug: Let's see what's actually running on this system
            if path == '/debug':
                # Return system information instead of trying web interface
                debug_info = f"""
OPNsense Debug Info:
Hostname: {subprocess.run(['hostname'], capture_output=True, text=True).stdout.strip()}
Listening ports: {subprocess.run(['netstat', '-tlnp'], capture_output=True, text=True).stdout[:500]}
Interface info: {subprocess.run(['ifconfig'], capture_output=True, text=True).stdout[:500]}
"""
                response_data = {
                    'request_id': req_id,
                    'status': 200,
                    'headers': json.dumps({'Content-Type': 'text/plain'}),
                    'body': debug_info
                }
                subprocess.run([
                    'curl', '-s', '-k', '-X', 'POST',
                    'https://$MANAGEMENT_SERVER/api/request_queue.php?action=submit_response',
                    '-H', 'Content-Type: application/json',
                    '-d', json.dumps(response_data)
                ], timeout=10)
                continue
            
            # OPNsense web interface - try multiple endpoints
            urls_to_try = [
                f'https://10.0.0.1:443{path}',
                f'http://10.0.0.1:80{path}', 
                f'https://10.0.0.1:8443{path}',
                f'http://10.0.0.1:8080{path}'
            ]
            
            success = False
            for url in urls_to_try:
                try:
                    test_cmd = ['curl', '-s', '-k', '--connect-timeout', '3', '--max-time', '5', url.replace(path, '/')]
                    test_result = subprocess.run(test_cmd, capture_output=True, timeout=6)
                    if test_result.returncode == 0 and len(test_result.stdout) > 50:  # Got some content
                        # This endpoint works, use it
                        curl_cmd.extend(['-k', '--max-time', '25'])
                        curl_cmd.append(url)
                        success = True
                        break
                except:
                    continue
            
            if not success:
                # Fallback to default
                url = f'https://10.0.0.1{path}'
                curl_cmd.extend(['-k'])
                curl_cmd.append(url)
            
            try:
                result = subprocess.run(curl_cmd, capture_output=True, text=True, timeout=30)
                
                # Submit response
                response_data = {
                    'request_id': req_id,
                    'status': 200 if result.returncode == 0 else 500,
                    'headers': json.dumps({'Content-Type': 'text/html'}),
                    'body': result.stdout if result.returncode == 0 else result.stderr
                }
                
                subprocess.run([
                    'curl', '-s', '-k', '-X', 'POST',
                    'https://$MANAGEMENT_SERVER/api/request_queue.php?action=submit_response',
                    '-H', 'Content-Type: application/json',
                    '-d', json.dumps(response_data)
                ], timeout=10)
                
            except subprocess.TimeoutExpired:
                # Submit timeout response
                error_data = {
                    'request_id': req_id,
                    'status': 504,
                    'headers': json.dumps({'Content-Type': 'text/plain'}),
                    'body': 'Gateway timeout'
                }
                subprocess.run([
                    'curl', '-s', '-k', '-X', 'POST',
                    'https://$MANAGEMENT_SERVER/api/request_queue.php?action=submit_response',
                    '-H', 'Content-Type: application/json',
                    '-d', json.dumps(error_data)
                ], timeout=10)
except:
    pass
"
        fi
        
        sleep 5  # Poll every 5 seconds
    done
}

# Function to keep tunnel alive
keep_alive() {
    while true; do
        sleep $CHECKIN_INTERVAL
        
        # Get system information for checkin
        # Get OPNsense version with improved detection
        OPNSENSE_VERSION=$(opnsense-version 2>/dev/null | head -1 | tr -d '\n' | tr -d '\r')
        if [ -z "$OPNSENSE_VERSION" ] || [ "$OPNSENSE_VERSION" = "" ]; then
            OPNSENSE_VERSION=$(cat /usr/local/opnsense/version/core 2>/dev/null | tr -d '\n' | tr -d '\r')
        fi
        if [ -z "$OPNSENSE_VERSION" ] || [ "$OPNSENSE_VERSION" = "" ]; then
            OPNSENSE_VERSION=$(uname -r | sed 's/-.*//')
        fi
        if [ -z "$OPNSENSE_VERSION" ] || [ "$OPNSENSE_VERSION" = "" ]; then
            OPNSENSE_VERSION="unknown"
        fi
        
        UPTIME=$(uptime | cut -d',' -f1 | cut -d' ' -f4-5)
        WAN_IP=$(curl -s -k --connect-timeout 5 https://api.ipify.org || echo "unknown")
        
        # Get LAN IP - Improved FreeBSD/OPNsense method to get actual internal IP
        LAN_IP=""
        # Try to get from LAN interface (not WAN)
        for iface in em0 em1 igb0 igb1 re0 re1 bge0 bge1 vtnet0 vtnet1; do
            LAN_IP=$(ifconfig "$iface" 2>/dev/null | awk '/inet / && !/127\.0\.0\.1/ {print $2; exit}')
            if [ -n "$LAN_IP" ] && [ "$LAN_IP" != "$WAN_IP" ]; then
                break
            fi
        done
        # If still not found, get from routing table but exclude WAN IP
        if [ -z "$LAN_IP" ]; then
            LAN_IP=$(ifconfig 2>/dev/null | awk '/inet / && !/127\.0\.0\.1/ && !/169\.254\./ {print $2}' | grep -v "$WAN_IP" | head -1)
        fi
        # Final fallback
        if [ -z "$LAN_IP" ]; then
            LAN_IP="unknown"
        fi
        
        # Get IPv6 address - improved detection
        IPV6_ADDR=$(ifconfig 2>/dev/null | awk '/inet6 / && !/fe80:/ && !/::1/ {print $2; exit}')
        if [ -z "$IPV6_ADDR" ]; then
            IPV6_ADDR="unknown"
        fi
        
        # Send full checkin data
        RESPONSE=$(curl -s -k -X POST "https://$MANAGEMENT_SERVER/agent_checkin.php" \
            -H "Content-Type: application/json" \
            -d "{
                \"firewall_id\": \"$FIREWALL_ID\",
                \"agent_version\": \"$AGENT_VERSION\",
                \"opnsense_version\": \"$OPNSENSE_VERSION\",
                \"wan_ip\": \"$WAN_IP\",
                \"lan_ip\": \"$LAN_IP\",
                \"ipv6_address\": \"$IPV6_ADDR\",
                \"uptime\": \"$UPTIME\",
                \"auth_token\": \"$AUTH_TOKEN\"
            }")
        
        if [ $? -eq 0 ]; then
            echo "$(date): Checkin completed"
            
            # Check if there are any commands in the response
            if echo "$RESPONSE" | grep -q '"agent_update_available":true'; then
                echo "$(date): Agent update available, executing update"
                echo "$(date): Full response: $RESPONSE" >> /tmp/agent_debug.log
                UPDATE_CMD=$(echo "$RESPONSE" | grep -o '"agent_update_command":"[^"]*"' | cut -d'"' -f4)
                if [ -n "$UPDATE_CMD" ]; then
                    echo "$(date): Update command: $UPDATE_CMD"
                    
                    # Execute update command in background and continue running
                    echo "$(date): Starting update process in background..."
                    
                    # Log the exact command being executed
                    echo "$(date): Update command: $UPDATE_CMD" >> /tmp/agent_debug.log
                    
                    # Execute with explicit error handling
                    eval "$UPDATE_CMD" 2>&1 | tee -a /tmp/agent_debug.log &
                    
                    echo "$(date): Update process initiated in background, continuing normal operation"
                else
                    echo "$(date): No update command found in response" >> /tmp/agent_debug.log
                fi
            fi
            
            if echo "$RESPONSE" | grep -q '"opnsense_update_requested":true'; then
                echo "$(date): OPNsense update requested, executing update"
                UPDATE_CMD=$(echo "$RESPONSE" | grep -o '"opnsense_update_command":"[^"]*"' | cut -d'"' -f4)
                if [ -n "$UPDATE_CMD" ]; then
                    echo "$(date): Executing: $UPDATE_CMD"
                    eval "$UPDATE_CMD"
                    echo "$(date): OPNsense update completed"
                fi
            fi
        else
            echo "$(date): Checkin failed, attempting to re-establish tunnel"
            establish_tunnel
        fi
    done
}

# Main execution
if establish_tunnel; then
    echo "Starting tunnel services..."
    
    # Start request handling in background
    handle_requests &
    REQUEST_PID=$!
    
    # Start keep-alive loop
    keep_alive &
    KEEPALIVE_PID=$!
    
    # Wait for any process to exit
    wait $REQUEST_PID $KEEPALIVE_PID
else
    echo "Failed to establish initial tunnel connection"
    exit 1
fi